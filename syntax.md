# 文法

## 変数宣言

不要です．

## 代入

＝ではなく```<-```を使用して，通常のプログラム言語と同じように右辺を左辺に代入できる．
また，```->```を使用して，左辺を右辺に代入できる．

```
x <- 10  // xに10を代入
20 -> y  // yに20を代入
```

## メソッド

### メソッドの定義

メソッドは，無名関数を変数に代入する形で定義する．
(パラメータ) => do〜endのブロックとして定義する．

```
// 無名関数を定義して，変数showに代入する
// パラメータなしのメソッドの定義についてはこれから考える
(str) => do
  str -> console
end -> show
```

### メソッドの実行

パラメータが不要であれば，メソッド名を書くだけで実行する．
パラメータが必要な場合は，メソッド名の直後にパラメータを書く．
パイプライン演算子でパラメータとメソッド名をつなぐこともできる．

```
// example 1
show "Hello"

// example 2
"Hello" -> show
```

## パイプライン構文

最近，各種言語で騒がれているパイプライン構文である．
本言語の場合は，```->```がその記号である．

本言語では，パイプライン構文を使用して，複数の動作を同じように記述できる．

1. インスタンス -> インスタンスメソッド
1. パラメータ　-> メソッド
1. パラメータ　-> 変数
1. 値 -> 新しい変数

```
// 変数への代入
// 初出のシンボルは新しい変数への代入とみなす
10 -> x  // xに10を代入する

// メソッドの実行
// メソッドのパラメータを記述することができる
"Hello" -> show  // "Hello"を表示する

// メソッドチェーン
// Rubyなどでよく使われるメソッドチェーンもパイプラインで記述できる

//Rubyの例：文字列を小文字にして，スペースで区切って，単語の先頭を大文字にして，スペース区切りで結合する
"this is a pen".downcase.split.map(&:capitalize).join(" ")
=> "This Is A Pen"

// 少し省略しない書き方
 "this is a pen".downcase.split.map { |x| x.capitalize }.join(" ")
 => "This Is A Pen"
 
 "this is apen" -> downcase -> split -> ここの書式は考え中 -> join " "
  => "This Is A Pen"

 ```
 
 
